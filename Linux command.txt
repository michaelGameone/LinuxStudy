==========================================
$                                        $
$     (A) Finding Files or Directories   $
$                                        $ 
==========================================

(1) Find
|__ It is a command for search the location of certain files and directories
|__ syntax: find [the location of the directory where the search starts (relative or absolute path)] -name [name list of files/directories]

example 1:
find . -name "abc.txt"
where the search start from the current directory (i.e. ".") and the target file name is "abc.txt"  

example 2:
find / -name "abc.txt" 
It will search the file starting from the root directory "/"

(2) Locate
* need to install "mlocate" before using this command:
(1) apt install mlocate
OR
(2a) rpm -qa | grep mlocate
(2b) yum install mlocate

Also, if "locate" command does not output any results, then as root run "updatedb"

|__ it use a "DB" to store the file location information in a "DB" or cache.
|__ therefore, it runs faster than "Find" command, but may not be updated with "DB". Therefore, need to 
    run "updatedb"
|__ syntax: locate [name file]

example:
locate abc.txt
==> it will search the whole machine for the target file named "abc.txt"







=========================================================
$                                                       $ 
$ (B) Create, Delete, Copy and Move files/directories   $ 
$                                                       $ 
=========================================================

(1) mv
|__ it is a command for moving file(s)/directory(ies) to new location
|__ syntax: mv [files list/directories list (in the current directory or relative path/absolute path)] [destination (relative path/absolute path]

Example:
Suppose there is a file called "abc" inside "ParentFolder" folder.
And there is a sub-folder called "ChildFolder" nested inside "ParentFolder"
Inside the "ChildFolder, type the following:
mv ./../abc .

It will move the file originally located in relative path "./../abc" where "." means current directory and ".." means parent directory to
the new directory "." which mean the current directory where the command is typed "i.e. the "ChildFolder".

|__ Rename a existing file:
    |__ mv existingFileName newFileName


(2) cp
|__ example 1: cp existingFile newFile
|__ example 2: cp existingFile AnOtherDirecoty
|__ example 2: cp -R existingDirectory newDirectory


(3) rm
|__ example 1: rm delFileName    

(4) mkdir

(5) rmdir or rm -r



==========================================
$                                        $
$            (C) Wild Card               $
$                                        $ 
==========================================

WildCard placeholder
(1) * : this represent a zero, one or more than one character(s)
(2) ? : represent a single character
(3) {} : represent a range of characters
(4) [] : represent a single character from a set of characters inside the bracket []
(5) \ : as an escape character
(6) ^ : the beginning of the line
(7) $ : the end of the line

Example 1:
(1) create some files first as follows:
touch abc abc1 abcd ab abc.con

(2) Delete all files starting with "abc"
rm abc*

(3) the result is only the following file left:
ab

Example 2:
touch abc{d..f}{1..2}

The result is 6 files are created as follows:
abcd1 abcd2 abce1 abce2 abcf1 abcf2


Example 3:
ls -l *.txt
It will list out all the text files

Example 4:
(1) create some files as follows:
touch abccd abcd abc ab
==> files created: abccd abcd abc ab

(2) 
command 1: ls -l ab?d
it will only list out the following files:
abcd

command 2: ls -l ab?
abc

Example 5:
(1) create the belows files
file1 file2 file12

(2) ls -l *[12]
==> file1 file2 file12

(3) ls -l *[1]
==> file1 

(4) ls -l *[2]
==> file2 file12

==========================================
$                                        $
$       (D) Soft and Hard Link           $
$                                        $ 
==========================================
Suppose there is a file called "originalFile" inside "ParentFolder"
And there is sub-folder called "ChildFolder" nested inside "ParentFolder"
Inside the "ChildFolder", create the soft link and hard link as follows:

ln -s ./../originalFile softLinkHere
ln ./../originalFile hardLinkHere

after you create the link, u will see "softLinkHere" has the properties starting with letter "l" to represent it is a soft link
On the other hand, u will see "hardLinkHere" has the properties starting with "-" ti represen it is a file, but with pointer count(inode) = 2 to 
indicate that there is 2 files pointing to one actual file location with the same inode (you can type "ls -li" to list out the inode number. They should be the same)


if you change one of the 3 files (namely, originalFile, softLinkHere or hardLinkHere), all 3 files will change

But if you remove the original file (i.e.originalFile), the "softLinkHere" becomes invalid but "hardLinkHere" still here but with file pointer count reduce to 1

==========================================
$                                        $
$       (E) File permission              $
$                                        $ 
==========================================
(1) Ownership of the file
User ==> the use who create the file
Group ==> the group that the user (who in turn create the file) belongs to


(2) Change file permission

command: chmod

Example 1: 
==> discard "read" permission for group user:
chmod g-r fileName

Example 2: 
==> add "read" permission for group user:
chmod g+r fileName



Example 2: 
==> add "read" permission for group user:
chmod g+r fileName


Example 3: 
==> remove "read" permission for ALL user:
chmod a-r fileName


Example 4: 
==> remove "read" permission for you:
chmod u-r fileName


Example 5: 
==> remove "read" permission for others user (i.e. except you and group):
chmod o-r fileName


Example 6:
==> remove access right to directory for others user
chmod o-x directoryName

Using the number to assign right
- 0: no permission
- 1: execute
- 2: write
- 3: execute and write
- 4: read
- 5: read and execute
- 6: read and write
- 7: read and write and execute

example:
chmod 764 fileName
==> it will end ups property "-rwxrw-r--"


(3) Change ownership

command: chown
|__ changes user ownership of a file

command: chgrp
|__ changes group ownership

Recursive change:
|__ -R

chown newOwnerName fileName
chown newUserOwner:newGroupOwner fileName
chgrp newGroupName fileName

The permission of the directory will override all the files and directories nested inside it.



(4) Access Control List (ACL)
* may need to install acl first with the following command:
apt install acl



command: setfacl
add perssion for a specific user
|__ syntax: setfact -m u:[use name]:[access right: rwx] [path of the target file]

add permission for a group
|__ syntax: setfacl -m g:[group name]:[access right: rwx] [path of the target file]

allow all files or directories to inherit ACL entries from the directory it is within
|__ syntax: setfacl -Rm "entry" [path of the target directory]


remove entry
|__ syntax: setfacl -x u:[user name] [path of the target file]


remove all entries
|__ syntax: setfacl -b [path of the target file]


command: getfacl
|__ syntax: getfacl [file name]


==========================================
$                                        $
$       (F) Input and Output             $
$                                        $ 
==========================================
In linux, everything (including devices, drive) is file
Therefore, standard input is a file with file descriptor = 0
Standard output is a file with file descriptor = 1
Standard error is a file with file descriptor = 2

Default output of command is 1

Example: feeding the input into the cmd "mail"

(1) redirect input from a file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mail -s "mail title" targetEmail@address.com < letterContent


(2) direct error output to a file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls -l /root 2> errorFile
telnet localhost 2> errorfile

(3) Add text to files
~~~~~~~~~~~~~~~~~~~~~~~~~            
(a) vi
(b) > or >> (redirect output to a file)
(c) echo > or >>


(i) echo
|__ create file with text already
example: echo "some text here" > newFileName

(ii) append some text to existing file
example: echo "some more text here" >> existingFileName

(iii) > or >> (redirect output to a file)
|__ you can direct any text output of any linux command (e.g. ls) to a file

example: ls -l > fileName

you can mixed "<" and ">"/">>" executed from left to right
example:
cat < file1 >> file2
|__ it will append file1 content to file2


(4) counting words in text file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(a) wc -c fileName


(5) tee command
~~~~~~~~~~~~~~~~~~~~~~~~~ 
tee command can store and view the output at the same time
example:
echo "some text" | tee newFileName

if append text to existing file
echo "more text" | tee -a existingFileName


(6) PIPES "|"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
==> connect the ouput from first command to the input of the second command

example:
ls -ltr | more


(7) Cat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


(8) more
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
display one page at a time when press the spacebar

cat fileName | more
Or
more fileName


(9) less
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
display one page ==> space bar
display one line down ==> j/down arrow
display one line up ==> k/up arrow

cat fileName | less
Or
less fileName


(10) head
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
display first N lines of the file ==> head -N fileName

e.g. head -2 fileName
     |__ display first 2 lines of the file



(11) tail
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
display last N Lines of the file ==> tail -N fileName

e.g. tail -2 fileName
     |__ display last 2 lines of the file
	 
	 
(12) cut
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose there is a csv like the following:

OrderID,CustomerID,ProductID,Qty,Date
1,3,5,1,2023-8-3
2,3,8,10,2024-3-1
3,2,11,3,2024-3-2

cut -d, -f 3 csvFileName 
|__ the following is the output:
ProductID
5
8
11

- syntax: cut -d[delimiter character] -f [which column(s) after delimited] [csv file name]

example
cut -d, -f 2-5 csvFileName 
|__ the following is the output:

CustomerID,ProductID,Qty,Date
3,5,1,2023-8-3
3,8,10,2024-3-1
2,11,3,2024-3-2



example
cut -d, -f 2,5 csvFileName 
|__ the following is the output:
CustomerID,Date
3,2023-8-3
3,2024-3-1
2,2024-3-2


It can be used for getting the piped data

example
ls -l | cut -c2-4



(13) awk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose a table like below

Date forecast temp
2023-3-8 sunny  23
2023-3-9 rainny 21
2023-3-10 cloudy 20

awk '{print $1}' tableFileName
|__ the following is the output
Date
2023-3-8
2023-3-9
2023-3-10

awk '{print $1, $3}' tableFileName
|__ the following is the output
Date temp
2023-3-8 23
2023-3-9 21
2023-3-10 20

awk '{print $NF}' tableFileName
|__ the following is the output
temp
23
21
20


It also can use the piped data:
///////////////////////////////////
ls -l | awk '{print $9}'


Find all the lines contain specific words:

Suppose there is conversation with the following content
`````````````````````````````````````````````````````````
hello John
Very nice to meet you!
How are you doing John?
I hope you are fine.
Bye John

Let's find all sentence including the word "John"
==> awk '/John/ {print}' conversationFile
|__ the following is the output:
hello John
How are you doing John?
Bye John

awk can also used to extract columns of CSV
==> awk -F, '{print $1}' csvFileName
OrderID
1
2
3

syntax: awk -F[delimiter] '{print $[column no]' [csv file name]


Replace certain column name with the new one:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
echo "hello john" | awk '{$2="Adam"; print $0}'
==> hello Adam

echo "hello john" | awk '{$2="Adam"; print $1}'
==> hello

echo "hello john" | awk '{$2="Adam"; print $2}'
==> Adam


example 2:
cat fileName | awk '$2="snowy"; print $0}'

output:
Date snowy temp
2023-3-8 snowy 23
2023-3-9 snowy 21
2023-3-10 snowy 20

Find the row with matching column value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose a table like below

Date forecast temp
2023-3-8 sunny  23
2023-3-9 rainny 21
2023-3-10 cloudy 20

how find all the rainny day
|__ awk '{if($2 == "rainny") print $0;}' tableFileName

output:
2023-3-9 rainny 21

Count how many columns
~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls -la | awk '{print NF}'




(14) grep and egrep
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(1) find all the lines with the matching keywords
syntax: grep keyword fileName

example 1:
grep John conversation

Output:
hello John
How are you doing John?
Bye John

example 2:
grep -c John conversation
|__ return how many lines matching the keyword

Output:
3

example 3:
grep -i jOHn conversation
|__ return how many lines matching the keyword (case insensitive)


example 4:
grep -n John conversation
|__ return line number and the matching lines 

example 5:
grep -v John conversation
|__ return line NOT matching the condition

example 6:
egrep -i "Hello|Bye|" converstion
|__ return line matching one of the keywords in the set




(15) sort
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sort the lines in the file in the alphabetical/numerical order

syntax 1: sort filename
        |__ sort in ascending order
		
syntax 2: sort -r filename
        |__ sort in descending order
		
example 1: egrep -ni "hello|bye" conversation | sort -r

output:
5:Bye John
1:hello John

example 2: ls -la | sort
example 3: ls -la | sort -k9
           |__ sorting the files listing information for the colume 9 (i.e. the file/direcotry name)
		  

(16) uniq
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
syntax: sort filename | uniq
        |__ elimate the duplicated lines
		


(17) wc
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
syntax: wc fileName


(10) Compare files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff file1 file2
|__ output the lines that are different

cmp file1 file2
|__ output the line number that are different


(11) Compress and Uncompress file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



==========================================
$                                        $
$       (G) date time                    $
$                                        $ 
==========================================
(1) command: date


==========================================
$                                        $
$  (H) Compress an Uncompress file       $
$                                        $ 
==========================================
(1) tar
Compression:
|__ syntax: tar cvf [final tar file name] [source files+directories path]

Uncompression:
|__ synctax: tar xvf [tar file name]

compress example:
tar cvf everything.tar .

uncompress example:
tar xvf everything.tar


(2) gzip -d OR gunzip
Compression:
|__ syntax: gzip [target file(s)]

example: gzip someFile

Uncompression:
|__ syntax: gunzip [target file(s)]

==========================================
$                                        $
$  (I) Vi and Vim Editor                 $
$                                        $ 
==========================================
Mode:
Insert Mode (I)
|__ after the insert mode: you can freely type any text you want to the file
|__ press "Ecape" to exit the insert mode

Command Mode
|__ press "shift"+"Z" +"Z" to save and exit the vi
|__ type :qw! to save and exit the vi
|__ in command mode, you can do the following:
    |__ type dd to remove the whole line
    |__ type U to undo
	|__ type x to delete one character at a time
	|__ type O to insert a new line
	|__ type /[the search word]
	|__ :q! ==> quit without saving
	
https://www.openvim.com/

https://vim-adventures.com/


==========================================
$                                        $
$  (J) Text Replacement                  $
$                                        $ 
==========================================

Command: Sed
|_ syntax: sed 's/[target wordling]/[replacement wording]/g'[name of the target file]
|__ output: only change on the screen output, not the file

|_ syntax: sed -i 's/[target wordling]/[replacement wording]/g'[name of the target file]
|__ output: change to the file


remove the word
|_ syntax: sed 's/[target wordling]//g'[name of the target file]

delete the line containing specific words
|__ syntax: sed '/[target wording]/d' [target file]

delete the empty line containing specific words
|__ syntax: sed '/^$/d" [target file]


==========================================
$                                        $
$       (K) User Management              $
$                                        $ 
==========================================











